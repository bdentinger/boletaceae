<!doctype html>
<html>
<head>
  <meta charset="utf-8"/>
  <title>Boletaceae Backbone Tree</title>
  <meta name="viewport" content="width=device-width, initial-scale=1"/>
  <style>
    :root { --bg:#fff; --fg:#111; --muted:#666; --line:#555; }
    html, body { margin:0; height:100%; background:var(--bg); color:var(--fg); font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, "Apple Color Emoji", "Segoe UI Emoji"; }
    header { padding: 12px 16px; border-bottom: 1px solid #ddd; display:flex; gap:12px; align-items:center; flex-wrap:wrap; }
    header h1 { font-size:16px; margin:0 8px 0 0; font-weight:600; }
    #meta { display:flex; gap:8px; align-items:center; flex-wrap:wrap; }
    button, input { font-size:14px; padding:6px 10px; }
    #viewer { width: 100vw; height: calc(100vh - 68px); }
    #svg { width:100%; height:100%; display:block; }
    .edge { stroke: var(--line); stroke-width: 1; fill: none; }
    .tip { font-size: 10px; fill: var(--fg); }
    .node { fill: var(--muted); }
    .hit { fill: crimson !important; }
    #status { font-size:12px; color:#555; margin-left:6px; }
  </style>
</head>
<body>
  <header>
    <h1>Boletaceae Backbone</h1>
    <div id="meta">
      <button id="zoomIn"  title="Zoom in">+</button>
      <button id="zoomOut" title="Zoom out">−</button>
      <button id="zoomFit" title="Fit to screen">Fit</button>
      <input id="search" placeholder="Search tip…" />
      <span id="status"></span>
    </div>
  </header>

  <div id="viewer">
    <svg id="svg" aria-label="Phylogeny"></svg>
  </div>

  <!-- Pure D3 (no eval), works with strict CSPs -->
  <script type="module">
  import * as d3 from "https://cdn.jsdelivr.net/npm/d3@7/+esm";

  const TREE_URL = "latest/backbone.newick";

  // Tunables
  let BRANCH_PX_PER_UNIT = 180;  // horizontal scale by branch length
  let TIP_SPACING_PX     = 14;   // vertical pixels per tip
  let BASE_FONT_PX       = 10;   // label font size at scale=1
  let SHOW_LABELS_AT_K   = 0.3;  // hide labels when zoomed out below this
  let LABEL_MODE         = "auto"; // "auto" | "genus" | "species" | "off"

  // Optional: little UI knobs (add as needed)
  const meta = document.getElementById("meta");
  const spacingInp = document.createElement("input");
  spacingInp.type = "range"; spacingInp.min = 8; spacingInp.max = 24; spacingInp.value = TIP_SPACING_PX;
  spacingInp.title = "Tip spacing";
  meta.appendChild(spacingInp);

  const fontInp = document.createElement("input");
  fontInp.type = "range"; fontInp.min = 8; fontInp.max = 18; fontInp.value = BASE_FONT_PX;
  fontInp.title = "Font size";
  meta.appendChild(fontInp);

  const modeSel = document.createElement("select");
  ["auto","species","genus","off"].forEach(m => { const o=document.createElement("option"); o.value=m; o.textContent=m; modeSel.appendChild(o); });
  modeSel.title = "Label mode";
  meta.appendChild(modeSel);

  async function fetchText(u){ const r=await fetch(u,{cache:"no-store"}); if(!r.ok) throw new Error(r.statusText); return r.text(); }

  function parseNewick(str){
    const s=str.trim().replace(/;+$/,"");
    const toks=s.split(/\s*(;|\(|\)|,|:)\s*/).filter(Boolean);
    let stack=[], node={}, root=node, expectLen=false;
    for(const t of toks){
      if(t==="("){ const n={children:[]}; (node.children||(node.children=[])).push(n); stack.push(node); node=n; expectLen=false; }
      else if(t===","){ const n={}; stack[stack.length-1].children.push(n); node=n; expectLen=false; }
      else if(t===")"){ node=stack.pop(); expectLen=true; }
      else if(t===":"){ expectLen=true; }
      else{ if(expectLen && !isNaN(+t)){ node.length=+t; expectLen=false; } else { node.name=node.name||t; expectLen=false; } }
    }
    return root.children?.[0] ?? root;
  }

  function toHierarchy(r){ return d3.hierarchy(r, d=>d.children); }

  function layout(h){
    // x = tip index (later scaled by TIP_SPACING_PX), y = cumulative branch length * BRANCH_PX_PER_UNIT
    h.each(d=>{ d.data._len = +d.data.length || 0; });
    h.eachBefore(d=>{ d.cum=(d.parent?.cum||0)+d.data._len; });
    let i=0;
    h.eachAfter(d=>{ d.x = d.children ? d.children.reduce((a,c)=>a+c.x,0)/d.children.length : (i++); });
    h.each(d=>{ d.y = d.cum * BRANCH_PX_PER_UNIT; d.X = d.x * TIP_SPACING_PX; }); // X is pixel y-position
    return h;
  }

  function genusOf(s){ return (s||"").split(/[_\s|]/)[0]; }
  function speciesOf(s){
    // assumes Genus_species or Genus_sp.; keeps as-is if already short
    if(!s) return "";
    const parts = s.split(/[|]/)[0]; // strip pipe metadata if any
    return parts;
  }

  function labelText(d, k){
    if(LABEL_MODE==="off") return "";
    if(LABEL_MODE==="genus") return genusOf(d.data.name);
    if(LABEL_MODE==="species") return speciesOf(d.data.name);
    // auto: show genus when zoomed far out; species when zoomed in
    return k < 1 ? genusOf(d.data.name) : speciesOf(d.data.name);
  }

  function render(url){
    const svg=d3.select("#svg"); svg.selectAll("*").remove();
    const gZoom=svg.append("g").attr("id","gZoom");
    const g=gZoom.append("g").attr("id","gTree");

    fetchText(url).then(nw=>{
      const h = layout(toHierarchy(parseNewick(nw)));

      // edges
      const edges = g.selectAll("path.edge")
        .data(h.links())
        .enter().append("path")
        .attr("class","edge")
        .attr("d",d=>`M${d.source.y},${d.source.X}H${d.target.y}V${d.target.X}`);

      // nodes
      g.selectAll("circle.node")
        .data(h.descendants())
        .enter().append("circle")
        .attr("class","node")
        .attr("r",1.5)
        .attr("cx",d=>d.y)
        .attr("cy",d=>d.X);

      // labels (tips only), content set in zoom handler for dynamic mode
      const tips = g.selectAll("text.tip")
        .data(h.leaves())
        .enter().append("text")
        .attr("class","tip")
        .attr("x",d=>d.y+4)
        .attr("y",d=>d.X+3)
        .text("")  // filled later
        .attr("font-size", `${BASE_FONT_PX}px`)
        .attr("fill","#111");

      // zoom/pan
      const zoom = d3.zoom().scaleExtent([0.03, 40]).on("zoom", (ev)=>{
        gZoom.attr("transform", ev.transform);
        updateLabels(ev.transform.k);
      });
      svg.call(zoom);

      function updateLabels(k){
        // Hide labels when too zoomed out
        if(LABEL_MODE==="off" || k < SHOW_LABELS_AT_K){
          tips.text("");
          return;
        }
        tips.text(d => labelText(d, k))
            .attr("font-size", `${BASE_FONT_PX * Math.min(1.5, Math.max(0.6, k))}px`);
      }

      function fit(){
        const b=g.node().getBBox();
        const vw=svg.node().clientWidth, vh=svg.node().clientHeight;
        if(b.width===0||b.height===0) return;
        const s=0.95*Math.min(vw/b.width, vh/b.height);
        const tx=(vw-b.width*s)/2 - b.x*s, ty=(vh-b.height*s)/2 - b.y*s;
        svg.transition().duration(350).call(zoom.transform, d3.zoomIdentity.translate(tx,ty).scale(s));
        setTimeout(()=>{ svg.call(zoom.transform, d3.zoomIdentity.translate(tx,ty).scale(s)); updateLabels(s); }, 360);
      }

      // buttons you already have in the header
      document.getElementById("zoomIn").onclick  = ()=> svg.transition().duration(150).call(zoom.scaleBy, 1.25);
      document.getElementById("zoomOut").onclick = ()=> svg.transition().duration(150).call(zoom.scaleBy, 0.8);
      document.getElementById("zoomFit").onclick = fit;

      // live knobs
      spacingInp.oninput = (e)=>{ TIP_SPACING_PX=+e.target.value; layout(h); redraw(); };
      fontInp.oninput    = (e)=>{ BASE_FONT_PX=+e.target.value; updateLabels(currentK); };
      modeSel.onchange   = (e)=>{ LABEL_MODE=e.target.value; updateLabels(currentK); };

      let currentK = 1;
      function redraw(){
        // recompute coordinates from stored h (x->X, y stays)
        h.each(d=>{ d.X = d.x * TIP_SPACING_PX; });
        edges.attr("d", d=>`M${d.source.y},${d.source.X}H${d.target.y}V${d.target.X}`);
        g.selectAll("circle.node").attr("cy", d=>d.X).attr("cx", d=>d.y);
        tips.attr("x", d=>d.y+4).attr("y", d=>d.X+3);
        updateLabels(currentK);
      }

      svg.on("wheel.zoom", null); // ensure default zoom binding only from d3.zoom
      svg.call(zoom);
      fit();

      // track current zoom scale for label mode
      svg.on("zoom", (ev)=>{ currentK = ev?.transform?.k ?? currentK; });

      // initial label update
      updateLabels(1);
    }).catch(e=>{
      console.error(e);
      const s=document.getElementById("status"); if(s) s.textContent="Failed to load tree.";
    });
  }

  render(TREE_URL);
</script>
</body>
</html>
