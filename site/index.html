<!doctype html>
<html>
<head>
  <meta charset="utf-8"/>
  <title>Boletaceae Backbone Tree</title>
  <meta name="viewport" content="width=device-width, initial-scale=1"/>
  <style>
    :root { --bg:#fff; --fg:#111; --muted:#666; --line:#555; }
    html, body { margin:0; height:100%; background:var(--bg); color:var(--fg); font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, "Apple Color Emoji", "Segoe UI Emoji"; }
    header { padding: 12px 16px; border-bottom: 1px solid #ddd; display:flex; gap:12px; align-items:center; flex-wrap:wrap; }
    header h1 { font-size:16px; margin:0 8px 0 0; font-weight:600; }
    #meta { display:flex; gap:8px; align-items:center; flex-wrap:wrap; }
    button, input { font-size:14px; padding:6px 10px; }
    #viewer { width: 100vw; height: calc(100vh - 68px); }
    #svg { width:100%; height:100%; display:block; }
    .edge { stroke: var(--line); stroke-width: 1; fill: none; }
    .tip { font-size: 10px; fill: var(--fg); }
    .node { fill: var(--muted); }
    .hit { fill: crimson !important; }
    #status { font-size:12px; color:#555; margin-left:6px; }
  </style>
</head>
<body>
  <header>
    <h1>Boletaceae Backbone</h1>
    <div id="meta">
      <button id="zoomIn"  title="Zoom in">+</button>
      <button id="zoomOut" title="Zoom out">−</button>
      <button id="zoomFit" title="Fit to screen">Fit</button>
      <input id="search" placeholder="Search tip…" />
      <span id="status"></span>
    </div>
  </header>

  <div id="viewer">
    <svg id="svg" aria-label="Phylogeny"></svg>
  </div>

  <!-- Pure D3 (no eval), works with strict CSPs -->
  <script type="module">
    import * as d3 from "https://cdn.jsdelivr.net/npm/d3@7/+esm";

    const TREE_URL = "latest/backbone.newick";   // build_site.py writes this

    async function fetchText(url) {
      const r = await fetch(url, {cache: "no-store"});
      if (!r.ok) throw new Error(`${r.status} ${r.statusText}`);
      return r.text();
    }

    // Tiny Newick parser (names + branch lengths), no eval
    function parseNewick(str) {
      const s = str.trim().replace(/;+$/, "");
      const toks = s.split(/\s*(;|\(|\)|,|:)\s*/).filter(Boolean);
      let stack = [], node = {}, root = node, expectLen = false;
      for (const t of toks) {
        if (t === "(") {
          const n = {children: []};
          if (!node.children) node.children = [];
          node.children.push(n);
          stack.push(node);
          node = n;
          expectLen = false;
        } else if (t === ",") {
          const n = {};
          stack[stack.length-1].children.push(n);
          node = n;
          expectLen = false;
        } else if (t === ")") {
          node = stack.pop();
          expectLen = true;
        } else if (t === ":") {
          expectLen = true;
        } else {
          if (expectLen && !isNaN(+t)) {
            node.length = +t;
            expectLen = false;
          } else {
            node.name = (node.name ? node.name : t);
            expectLen = false;
          }
        }
      }
      return root.children?.[0] ? root.children[0] : root;
    }

    function toHierarchy(root) {
      return d3.hierarchy(root, d => d.children);
    }

    function layout(h) {
      // Compute cumulative branch lengths (y) and tidy x spacing
      const k = 180; // pixels per unit branch length (tune for density)
      h.each(d => { d.data._len = +d.data.length || 0; });
      // assign cum length from root
      h.eachBefore(d => {
        d.cum = (d.parent?.cum || 0) + (d.data._len || 0);
      });
      // compute tip order (simple tidy layout)
      let i = 0;
      h.eachAfter(d => {
        if (d.children) d.x = d.children.reduce((a,c)=>a+c.x,0)/d.children.length;
        else d.x = i++;
      });
      h.each(d => { d.y = d.cum * k; });
      return h;
    }

    function render(url) {
      const svg = d3.select("#svg");
      svg.selectAll("*").remove();

      const gZoom = svg.append("g").attr("id","gZoom");
      const g = gZoom.append("g").attr("id","gTree");

      fetchText(url).then(nw => {
        const root = parseNewick(nw);
        const h = layout(toHierarchy(root));

        // edges (elbow lines)
        g.selectAll("path.edge")
          .data(h.links())
          .enter().append("path")
          .attr("class","edge")
          .attr("d", d => `M${d.source.y},${d.source.x}H${d.target.y}V${d.target.x}`);

        // nodes
        g.selectAll("circle.node")
          .data(h.descendants())
          .enter().append("circle")
          .attr("class","node")
          .attr("r", 1.5)
          .attr("cx", d => d.y)
          .attr("cy", d => d.x);

        // labels (tips only)
        g.selectAll("text.tip")
          .data(h.leaves())
          .enter().append("text")
          .attr("class","tip")
          .attr("x", d => d.y + 4)
          .attr("y", d => d.x + 3)
          .text(d => d.data.name || "");

        // zoom / pan
        const zoom = d3.zoom().scaleExtent([0.05, 20]).on("zoom", ev => gZoom.attr("transform", ev.transform));
        svg.call(zoom);

        // fit-to-viewBox
        function fit() {
          const b = g.node().getBBox();
          const vw = svg.node().clientWidth, vh = svg.node().clientHeight;
          if (b.width === 0 || b.height === 0) return;
          const s = 0.95 * Math.min(vw / b.width, vh / b.height);
          const tx = (vw - b.width * s)/2 - b.x * s;
          const ty = (vh - b.height * s)/2 - b.y * s;
          svg.transition().duration(350).call(zoom.transform, d3.zoomIdentity.translate(tx, ty).scale(s));
        }

        document.getElementById("zoomIn").onclick  = () => svg.transition().duration(150).call(zoom.scaleBy, 1.25);
        document.getElementById("zoomOut").onclick = () => svg.transition().duration(150).call(zoom.scaleBy, 0.8);
        document.getElementById("zoomFit").onclick = fit;
        fit();

        // simple search/highlight
        const status = document.getElementById("status");
        const input = document.getElementById("search");
        input.addEventListener("input", () => {
          const q = input.value.trim().toLowerCase();
          const tips = g.selectAll("text.tip");
          tips.classed("hit", d => q && (d.data.name || "").toLowerCase().includes(q));
          const hits = q ? tips.filter(function(){ return d3.select(this).classed("hit"); }).size() : 0;
          status.textContent = q ? `matches: ${hits}` : "";
        });
      }).catch(e => {
        console.error(e);
        document.getElementById("status").textContent = "Failed to load tree.";
      });
    }

    render(TREE_URL);
  </script>
</body>
</html>
