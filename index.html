<!doctype html>
<html>
<head>
  <meta charset="utf-8"/>
  <title>Boletaceae Backbone Tree</title>
  <meta name="viewport" content="width=device-width, initial-scale=1"/>
  <style>
    html, body { height: 100%; }
    body { font-family: ui-sans-serif, system-ui, -apple-system; margin: 0; color: #111; }
    header { padding: 12px 16px; border-bottom: 1px solid #ddd; display:flex; gap:12px; align-items:center; justify-content:space-between; }
    #viewer { width: 100vw; height: calc(100vh - 56px); }
    #tree { width: 100%; height: 100%; }
    #debug { position:fixed; right:8px; bottom:8px; background:#111; color:#eee; padding:6px 8px; font:12px/1.3 monospace; border-radius:6px; z-index:9999; opacity:.9 }
    a.btn { display:inline-block; padding:6px 10px; border:1px solid #ddd; border-radius:6px; text-decoration:none; color:#111; background:#fafafa }
    a.btn:hover { background:#f0f0f0 }
  </style>
  <!-- D3 only (CSP friendly; no eval needed) -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/d3/5.16.0/d3.min.js" crossorigin="anonymous"></script>
</head>
<body>
  <header>
    <strong>Boletaceae Backbone</strong>
    <nav>
      <a class="btn" href="latest/backbone.newick" download>Download Newick</a>
    </nav>
  </header>

  <div id="viewer"><div id="tree"></div></div>
  <div id="debug"></div>

  <script>
  // --- Minimal Newick parser (no eval) ---
  function parseNewick(s){
    s = s.trim().replace(/\[.*?\]/g, ''); // strip bracket comments
    let i = 0;
    function readName(){
      let n=""; while(i<s.length){
        const c=s[i]; if(c===':'||c===','||c===')'||c==='('||c===';') break;
        n+=c; i++;
      } return n.trim();
    }
    function readLength(){
      if(s[i]!==':') return null; i++;
      let x=""; while(i<s.length){
        const c=s[i]; if(c===','||c===')'||c===';') break;
        x+=c; i++;
      }
      const v=parseFloat(x);
      return Number.isFinite(v)?v:null;
    }
    function subtree(){
      let node={};
      if(s[i]==='('){
        i++; node.branchset=[];
        while(true){
          node.branchset.push(subtree());
          if(s[i]===','){ i++; continue; }
          if(s[i]===')'){ i++; break; }
          throw new Error("Malformed Newick near: "+s.slice(Math.max(0,i-10), i+10));
        }
        const nm = readName(); if(nm) node.name = nm;
      } else {
        const nm = readName(); if(nm) node.name = nm;
      }
      const len = readLength(); if(len!=null) node.length = len;
      return node;
    }
    const t = subtree(); if(s[i]===';') i++;
    return t;
  }

  async function loadAndRender(url){
    const dbgEl = document.getElementById('debug');
    const log = (m)=>{ dbgEl.textContent = (dbgEl.textContent?dbgEl.textContent+"\n":"")+m; console.log(m); };

    const r = await fetch(url, {cache:'no-store'});
    log(`GET ${url} â†’ ${r.status}`);
    if(!r.ok){ throw new Error(`HTTP ${r.status} for ${url}`); }
    let newick = (await r.text()).trim();
    if(!newick.endsWith(';')) newick += ';';

    const data = parseNewick(newick);
    const root = d3.hierarchy(data, d => d.branchset);

    // cumulative branch lengths for X scale
    (function setCum(n, acc){
      n.data._y = acc + (n.data.length || 0);
      (n.children||[]).forEach(c => setCum(c, n.data._y));
    })(root, 0);
    const yMax = d3.max(root.descendants(), d => d.data._y) || 1;

    // layout
    const W = document.getElementById('tree').clientWidth || 1200;
    const H = document.getElementById('tree').clientHeight || 800;
    const margin = {top: 10, right: 20, bottom: 10, left: 10};
    const width = W - margin.left - margin.right;
    const height = H - margin.top - margin.bottom;

    const cluster = d3.cluster().size([height, width - 180]);
    cluster(root);

    // X by order; Y by cumulative branch length
    const y = d3.scaleLinear().domain([0, yMax]).range([0, width - 180]);
    const leaves = root.leaves();
    let i = 0; root.eachBefore(n => n.x = (leaves.length>1 ? i++ * (height / (leaves.length-1)) : height/2));
    root.each(n => n.y = y(n.data._y));

    // draw
    const svg = d3.select('#tree').html('').append('svg').attr('width', W).attr('height', H);
    const g = svg.append('g').attr('transform', `translate(${margin.left},${margin.top})`);

    g.append('g').selectAll('path')
      .data(root.links())
      .enter().append('path')
      .attr('fill','none')
      .attr('stroke','#555')
      .attr('stroke-opacity',0.7)
      .attr('d', d => `M${d.source.y},${d.source.x}H${d.target.y}V${d.target.x}`);

    const node = g.append('g').selectAll('g')
      .data(root.descendants())
      .enter().append('g')
      .attr('transform', d => `translate(${d.y},${d.x})`);

    node.append('circle')
      .attr('r', 2.2)
      .attr('fill', d => d.children ? '#555' : '#111');

    node.filter(d => !d.children).append('text')
      .attr('dy','0.31em')
      .attr('x', 6)
      .text(d => d.data.name || '')
      .attr('font-size','12px');

    log(`tips: ${leaves.length}`);
  }

  document.addEventListener('DOMContentLoaded', () => {
    loadAndRender('latest/backbone.newick').catch(e => {
      const el = document.getElementById('debug');
      el.textContent = `Error: ${e.message}`;
      console.error(e);
    });
  });
  </script>
</body>
</html>
